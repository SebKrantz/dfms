% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/methods.R
\name{news}
\alias{news}
\alias{news.dfm}
\title{News Decomposition}
\usage{
news(object, ...)

\method{news}{dfm}(
  object,
  comparison,
  t.fcst,
  target.vars = NULL,
  groups = NULL,
  series = NULL,
  standardized = FALSE,
  ...
)
}
\arguments{
\item{object}{a \code{dfm} object for the old vintage.}

\item{\dots}{not used.}

\item{comparison}{a \code{dfm} object or a new dataset for the updated vintage.}

\item{t.fcst}{integer. Forecast target time index.}

\item{target.vars}{Integer or character identifying target variables. Defaults to all variables.}

\item{groups, series}{optional character vectors for grouping and naming variables.}

\item{standardized}{logical. Return results on standardized scale?}
}
\value{
For a single target, a \code{dfm.news} object with elements:
\itemize{
\item \code{y_old}: old forecast for the target variable at \code{t.fcst}.
\item \code{y_new}: new forecast for the target variable at \code{t.fcst}.
\item \code{singlenews}: named vector of news contributions by series.
\item \code{groupnews}: named vector of news contributions aggregated by group (if not \code{NULL}).
\item \code{gain}: named news weights for each new release.
\item \code{gain_scaled}: scaled gain for each new release (matches the data scale).
\item \code{actual}: actual values for the new releases.
\item \code{forecasts}: old forecasts for the new releases.
}
If \code{target.vars} selects multiple targets, a \code{dfm.news_list} object is returned,
where each element is a \code{dfm.news} object and list names correspond to targets.
}
\description{
Compute the Banbura and Modugno (2014) news decomposition of forecast updates.
Given an old vintage and an updated vintage, the function decomposes the
forecast revision at \code{t.fcst} into contributions from new releases.
}
\details{
Let \eqn{y_t^{old}} and \eqn{y_t^{new}} be the old and new forecasts of a target
series at \eqn{t = t_{fcst}}. For each new release \eqn{i} (a previously missing
observation that becomes observed), the innovation is
\deqn{\nu_i = x_i^{new} - \hat{x}_i^{old},}
where \eqn{\hat{x}_i^{old}} is the smoothed estimate from the old vintage.
The revision is decomposed as
\deqn{y_t^{new} - y_t^{old} = \sum_i g_i \nu_i,}
with gain weights computed from Kalman smoother covariances:
\deqn{g = \sigma_y C_y P_1 P_2^{-1}.}
Here \eqn{\sigma_y} is the target series standard deviation, \eqn{C_y} is the
loading row for the target series, \eqn{P_1} collects cross-covariances between
the target and each news item, and \eqn{P_2} is the covariance matrix of the
news items (including measurement error where appropriate). See Section 2.3 and
Appendix D in Banbura and Modugno (2014).

The function uses the system matrices and scaling from the new vintage. The old
data are re-standardized to the new-vintage scale before smoothing so that
innovations and gains are computed on a consistent scale. Set
\code{standardized = FALSE} to report results on the original data scale.
}
\note{
If the model was estimated with \code{max.missing < 1} and
\code{na.rm.method = "LE"} in \code{\link{tsnarmimp}} (called by \code{DFM()}), leading or trailing rows with many missing values
may be removed by \code{DFM()}. If old and new vintages are both dfm objects, and they drop different rows,
then \code{t.fcst} can become out of bounds. When \code{comparison} is provided
as raw data, \code{news()} drops \code{object$rm.rows} from the new dataset (if present) and
forces \code{max.missing = 1} for the re-estimation call to keep row alignment.
To avoid issues, use consistent ragged-edge patterns across vintages or estimate both vintages with \code{max.missing = 1}.
}
\references{
Banbura, M., & Modugno, M. (2014). Maximum likelihood estimation of factor
models on datasets with arbitrary pattern of missing data. Journal of Applied
Econometrics, 29(1), 133-160.
}
